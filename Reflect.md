- Learned how to develop a full-fledged game in JavaScript versus just adding simple additional interactivity to a website.
    - This required more planning & organization of code elements & also ensuring that those components would interact with each other well.
- Many things had to be changed from the design phase to the actual implementation.
    - Designed using a Java object-oriented context, and I was unfamiliar with game design.
    - Actual end product had much more functional programming aspects. As JavaScript works better in a functional context versus an object-oriented way.
- Managed scope by focusing on core functionality and taking out features that were “nice to have”.
    - This was challenging as when developing, I would start in a depth-first way (where I would just keep working on one thing until it was “perfect”), and many times this would take so much additional time than it took getting it up and running.
        - For instance, after I got the canvas on screen, I was focusing on a resizing & centering algorithm, that would also maintain coordinates properly as well as resize other elements. However, since this was not “crucial”, I had to shift to make other elements up and running.
- JavaScript has no strict compiling, so many times after changes were made to the program or algorithm, and it behaved oddly, I had to do much more intricate debugging to figure out what was going wrong.
- This included:
  - Using `console.log`
  - Using the Chrome developer debugger to set up breakpoints and trace through the code (very helpful).
- After moving to a more functional programming style for my game, it was tough to figure out how to implement certain functionality at first, since I was coming from an object-oriented background.
    - Learning how to use the “update” and “draw” methods, and how to create state variables, and event handlers to handle certain events such as a “goal” or “win” state was tough. My initial implementations were very clunky, however I slowly figured it out, and the main thing that made it easier was to use the parent class to handle state instead. Since I was trying to handle the state of a child class within the child class (like object orientation) it was tough for me, however when I used the parent to handle it, it made things much simpler.
        - For instance, to reset the game state, instead of creating a whole new method to reset all the game state variables, and those methods causing side effects, I instead just created a new `TableTopSoccer()` instance from the main class, which worked perfectly.
- I had to exclude the timer, and pause functionality of my game, and had to change the game rules to first to score three goals wins instead of who scores more goals within a 3-minute timespan. This is because the key game functionality & utility would still remain high, and be much simpler to implement than doing a timed system. Additionally, I didn’t think pausing the game was that crucial to functionality and would be good to include in the next iteration.
- I had chosen AI to help with initial design (how to structure the overall classes of the game), however after the very high-level structure, I had started work on the game myself, not using AI to generate code, however using it to learn about certain concepts. I.e., “How does canvas work, and how do I draw images on it?” I.e., “Common 2D ball collision algorithms.” And then using the information I learned to implement my game’s elements.
- One of the toughest parts for me to implement (to the point I almost took it out of the game scope) was the ability to switch between different players. This is mainly because I didn’t know which class to implement it in, and it would overlap with the features in another class. For instance: the “Player.js” class uses a mouse handler to detect x, y and hit a player on press & release. I wasn’t sure where I would put the code to switch between players, and make sure that it didn’t accidentally shoot into an unintended player instead. 
    - The solution I came up with was to instead use each player’s number to facilitate player switches, so instead of pressing a player you want to switch to (and potentially accidentally shooting them instead), you just press their number on your keyboard and it will switch position onto them.
